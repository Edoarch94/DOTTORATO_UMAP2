<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Viewer 3D</title>

<!-- Three.js (build “classico”, niente moduli) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152/examples/js/loaders/RGBELoader.js"></script>

<style>
  :root{--bg:#0f0f10;--panel:#161618;--accent:#4ade80}
  html,body{height:100%;margin:0;background:var(--bg);color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}

  header{padding:10px 14px;border-bottom:1px solid rgba(255,255,255,.07)}
  header h1{margin:0;font:700 16px/1.2 system-ui}

  .stage{position:relative}
  canvas{display:block;width:100%;height:100vh}

  /* pannello comandi */
  .panel{position:fixed;left:12px;bottom:12px;right:12px;display:grid;gap:10px;
         grid-template-columns:repeat(6, minmax(140px, 1fr));background:var(--panel);
         border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px}
  .group{background:rgba(255,255,255,.04);border-radius:10px;padding:8px;display:flex;flex-direction:column;gap:8px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  label{font-size:12px;opacity:.75}
  button{border:0;border-radius:10px;padding:8px 11px;background:#2a2a2a;color:#fff;font-weight:600;cursor:pointer}
  button.on{outline:2px solid rgba(74,222,128,.55)}
  input[type=range]{width:100%}

  /* hotspot numerati + popover */
  .hotspot{position:absolute;transform:translate(-50%,-50%);z-index:10}
  .hotspot .dot{width:26px;height:26px;border-radius:50%;display:flex;align-items:center;justify-content:center;
                background:#2b74ff;border:1px solid #fff;color:#fff;font:800 13px/1 system-ui;box-shadow:0 2px 6px rgba(0,0,0,.45);cursor:pointer}
  .popover{position:absolute;min-width:260px;max-width:360px;background:rgba(18,18,18,.96);border:1px solid rgba(255,255,255,.18);
           border-radius:12px;padding:12px;color:#fff;display:none}
  .popover.show{display:block}
  .popover h3{margin:0 0 6px;font:700 14px/1.2 system-ui}
  .popover p{margin:0;font-size:13px;opacity:.92}

  .err{position:fixed;top:12px;right:12px;background:#300;color:#fff;border:1px solid #922;padding:10px 12px;border-radius:10px;max-width:50ch}

  @media (max-width:980px){ .panel{grid-template-columns:repeat(3, minmax(140px, 1fr));} }
  @media (max-width:560px){ .panel{grid-template-columns:repeat(2, minmax(140px, 1fr));} }
</style>
</head>
<body>
<div class="wrap">
  <header><h1 id="title">Viewer 3D</h1></header>

  <div class="stage" id="stage">
    <canvas id="c"></canvas>
    <!-- hotspot container -->
    <div id="hs-layer" style="position:absolute;inset:0;pointer-events:none"></div>
  </div>

  <!-- pannello -->
  <div class="panel">
    <div class="group">
      <label>Camera</label>
      <div class="row">
        <button id="fit">Inquadra</button>
        <button id="reset">Reset</button>
        <button id="orbitToggle">Orbit ON/OFF</button>
      </div>
    </div>

    <div class="group">
      <label>Zoom (FOV)</label>
      <input id="fov" type="range" min="25" max="85" step="1" value="45">
    </div>

    <div class="group">
      <label>Luci</label>
      <div class="row">
        <button id="keyOn" class="on">Key</button>
        <button id="fillOn" class="on">Fill</button>
        <button id="rimOn"  class="on">Rim</button>
      </div>
      <label>Intensità</label>
      <input id="intensity" type="range" min="0" max="2" step="0.05" value="1.0">
    </div>

    <div class="group">
      <label>Ambiente</label>
      <div class="row">
        <button class="env" data-hdr="https://cdn.jsdelivr.net/npm/three@0.152/examples/textures/equirectangular/royal_esplanade_1k.hdr">HDR</button>
        <button class="env" data-hdr="none">None</button>
      </div>
    </div>

    <div class="group">
      <label>Sfondo</label>
      <div class="row">
        <button class="bg" data-bg="dark">Dark</button>
        <button class="bg" data-bg="light">Light</button>
        <button class="bg" data-bg="transparent">Transparent</button>
      </div>
    </div>

    <div class="group">
      <label>Hotspot</label>
      <div class="row">
        <button id="closePopovers">Chiudi popover</button>
      </div>
    </div>
  </div>
</div>

<div id="err" class="err" style="display:none"></div>

<script>
/* ========= 1) Normalizzazione parametri (viewer “furbo”) ========= */
const qs = new URLSearchParams(location.search);
const rawModel    = qs.get('model')    || '';
const rawHotspots = qs.get('hotspots') || '';
const title       = qs.get('title')    || 'Viewer 3D';
document.getElementById('title').textContent = title;
document.title = title;

/* Se il path è http(s) lo lascio; se inizia per "/" lo considero root-relative;
   altrimenti (es. "modelli/file.glb") lo rendo relativo a /viewer/ → "../modelli/file.glb" */
const toAbs = p => /^https?:\/\//i.test(p) ? p : (p.startsWith('/') ? p : `../${p}`);

const MODEL_URL    = toAbs(rawModel);
const HOTSPOTS_URL = toAbs(rawHotspots);

/* ========= 2) Setup Three.js ========= */
const canvas  = document.getElementById('c');
const hsLayer = document.getElementById('hs-layer');
const stage   = document.getElementById('stage');

const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:false});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.setSize(stage.clientWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101013);

const camera = new THREE.PerspectiveCamera(45, stage.clientWidth / window.innerHeight, 0.01, 100);
camera.position.set(1.5, 1.0, 1.8);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0, 0.6, 0);

/* Luci base: key/fill/rim (tutti togglabili) */
const keyLight  = new THREE.DirectionalLight(0xffffff, 1.0); keyLight.position.set( 1.5, 1.2,  1.2);
const fillLight = new THREE.DirectionalLight(0xffffff, 0.6); fillLight.position.set(-1.4, 0.8,  0.6);
const rimLight  = new THREE.DirectionalLight(0xffffff, 0.8); rimLight.position.set( 0.2, 0.8, -1.6);
scene.add(keyLight, fillLight, rimLight);

const envPMREM = new THREE.PMREMGenerator(renderer);
let hdrTexture = null;

/* ========= 3) Carica modello ========= */
const loader = new THREE.GLTFLoader();
THREE.Cache.enabled = true;
loader.setCrossOrigin('anonymous');

let rootModel = null;

function showError(msg){
  const o = document.getElementById('err');
  o.textContent = msg;
  o.style.display = 'block';
  console.error(msg);
}

loader.load(
  MODEL_URL,
  (gltf)=>{
    rootModel = gltf.scene;
    scene.add(rootModel);

    // Prova a centrare/inquadrare
    fitModel();

    // Dopo il load, prova a leggere gli hotspot
    if (HOTSPOTS_URL) loadHotspots(HOTSPOTS_URL);
  },
  (xhr)=>{ /* progress */ },
  (err)=> showError('Errore nel caricamento modello: ' + (err?.message || err))
);

/* ========= 4) Hotspot (da JSON) ========= */
const hotspotDots = []; // {el, pop, pos:THREE.Vector3}

async function loadHotspots(url){
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('Error: ' + res.status);
    const data = await res.json();

    data.forEach((h, idx)=>{
      const pos = new THREE.Vector3(...h.position);
      // bottone
      const hs = document.createElement('div');
      hs.className = 'hotspot';
      hs.style.pointerEvents = 'auto';
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.textContent = (h.id ?? (idx+1));
      hs.appendChild(dot);
      hsLayer.appendChild(hs);

      // popover
      const pop = document.createElement('div');
      pop.className = 'popover';
      pop.innerHTML = `<h3>${h.title || ('Hotspot ' + (idx+1))}</h3><p>${h.text || ''}</p>`;
      hsLayer.appendChild(pop);

      dot.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        // zoom dolce verso il punto
        smoothFocus(pos);
        // apre popover, chiude gli altri
        document.querySelectorAll('.popover.show').forEach(p=>p.classList.remove('show'));
        pop.classList.add('show');
        // posizionamento pop a sinistra/destra in base allo spazio
        placePopover(pop, hs.getBoundingClientRect());
      });

      hotspotDots.push({el:hs, pop, pos});
    });

    // chiudi quando clicchi lo sfondo
    hsLayer.addEventListener('click', ()=> {
      document.querySelectorAll('.popover.show').forEach(p=>p.classList.remove('show'));
    });

  }catch(e){
    showError('Errore JSON: ' + e);
  }
}

/* Proiezione 3D → 2D ad ogni frame */
function updateHotspots(){
  const w = stage.clientWidth, h = window.innerHeight;
  hotspotDots.forEach(hs=>{
    const p = hs.pos.clone().project(camera); // NDC
    const x = ( p.x * 0.5 + 0.5) * w;
    const y = (-p.y * 0.5 + 0.5) * h;
    hs.el.style.left = x + 'px';
    hs.el.style.top  = y + 'px';

    if (hs.pop.classList.contains('show')){
      placePopover(hs.pop, hs.el.getBoundingClientRect());
    }
  });
}

function placePopover(pop, rect){
  // di default mostro il pop a destra; se non c’è spazio vado a sinistra
  const margin = 12;
  pop.style.top = (rect.top + rect.height/2) + 'px';
  // lato
  const preferRight = rect.right + 320 < window.innerWidth - margin; // 320 ~ larghezza pop
  pop.style.left = (preferRight ? (rect.right + 14) : (rect.left - 14 - 320)) + 'px';
}

/* ========= 5) Utility camera ========= */
function fitModel(){
  // bounding box
  const box = new THREE.Box3().setFromObject(rootModel || scene);
  if(!box || !isFinite(box.min.x)) return;

  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);

  // punta al centro
  controls.target.copy(center);

  // stima distanza
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist = maxDim * 1.4 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));

  const dir = new THREE.Vector3(1.4, 1.1, 1.6).normalize(); // direzione “gradevole”
  camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
  camera.near = Math.max(0.001, dist/100);
  camera.far  = dist*50;
  camera.updateProjectionMatrix();
  controls.update();
}

/* zoom dolce verso una posizione */
function smoothFocus(targetVec3){
  const start = {
    px: camera.position.x, py: camera.position.y, pz: camera.position.z,
    tx: controls.target.x, ty: controls.target.y, tz: controls.target.z
  };
  const end = {
    px: targetVec3.x + 0.35, // leggera distanza laterale
    py: targetVec3.y + 0.25,
    pz: targetVec3.z + 0.35,
    tx: targetVec3.x, ty: targetVec3.y, tz: targetVec3.z
  };
  const t0 = performance.now(), DUR = 650;

  function easeInOut(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }

  function step(now){
    let k = Math.min(1, (now - t0)/DUR);
    const e = easeInOut(k);

    camera.position.set(
      start.px + (end.px - start.px)*e,
      start.py + (end.py - start.py)*e,
      start.pz + (end.pz - start.pz)*e
    );
    controls.target.set(
      start.tx + (end.tx - start.tx)*e,
      start.ty + (end.ty - start.ty)*e,
      start.tz + (end.tz - start.tz)*e
    );
    controls.update();
    if(k<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ========= 6) UI ========= */
const fov = document.getElementById('fov');
fov.addEventListener('input', e=>{
  camera.fov = +e.target.value;
  camera.updateProjectionMatrix();
});

document.getElementById('fit').onclick = fitModel;
document.getElementById('reset').onclick = ()=>{
  camera.fov = 45; camera.updateProjectionMatrix();
  controls.reset();
  fitModel();
};

const orbitBtn = document.getElementById('orbitToggle');
orbitBtn.onclick = ()=>{
  controls.enabled = !controls.enabled;
  orbitBtn.classList.toggle('on', controls.enabled);
};

const intensity = document.getElementById('intensity');
intensity.addEventListener('input', e=>{
  const v = +e.target.value;
  keyLight.intensity = v;
  fillLight.intensity = v*0.6;
  rimLight.intensity  = v*0.8;
});

document.getElementById('keyOn').onclick  = (e)=>{ keyLight.visible  = !keyLight.visible;  e.target.classList.toggle('on', keyLight.visible); };
document.getElementById('fillOn').onclick = (e)=>{ fillLight.visible = !fillLight.visible; e.target.classList.toggle('on', fillLight.visible); };
document.getElementById('rimOn').onclick  = (e)=>{ rimLight.visible  = !rimLight.visible;  e.target.classList.toggle('on', rimLight.visible); };

document.querySelectorAll('.env').forEach(btn=>{
  btn.onclick = ()=>{
    const src = btn.dataset.hdr;
    if(src === 'none'){
      scene.environment?.dispose?.();
      scene.environment = null;
      hdrTexture?.dispose?.(); hdrTexture = null;
      return;
    }
    new THREE.RGBELoader().load(src, (tex)=>{
      hdrTexture?.dispose?.();
      const env = envPMREM.fromEquirectangular(tex).texture;
      scene.environment = env;
      tex.dispose();
    }, undefined, err=> showError('HDR load error: ' + err));
  };
});

document.querySelectorAll('.bg').forEach(btn=>{
  btn.onclick = ()=>{
    const mode = btn.dataset.bg;
    if(mode === 'transparent'){
      renderer.setClearColor(0x000000, 0);
      scene.background = null;
    }else if(mode === 'light'){
      renderer.setClearColor(0xf3f3f3, 1);
      scene.background = new THREE.Color(0xf3f3f3);
    }else{
      renderer.setClearColor(0x101013, 1);
      scene.background = new THREE.Color(0x101013);
    }
  };
});

document.getElementById('closePopovers').onclick = ()=>{
  document.querySelectorAll('.popover.show').forEach(p=>p.classList.remove('show'));
};

/* ========= 7) Resize & render ========= */
function onResize(){
  renderer.setSize(stage.clientWidth, window.innerHeight);
  camera.aspect = stage.clientWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  updateHotspots();
  renderer.render(scene, camera);
}
animate();
onResize();
</script>
</body>
</html>
