<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Epigrafe Claudia Nova â€” Three.js</title>

<style>
  :root{--bg:#111;--card:#1b1b1b}
  html,body{height:100%;margin:0;background:var(--bg);color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{min-height:100dvh;display:flex;flex-direction:column;gap:12px;padding:12px}
  h1{margin:0 auto;font:700 20px/1.2 system-ui;width:min(96vw,1200px)}
  #stage{position:relative;width:min(96vw,1200px);height:min(80vh,760px);margin:0 auto;border-radius:14px;overflow:hidden;box-shadow:0 8px 28px rgba(0,0,0,.45);background:#0e0e0e}
  canvas{display:block;width:100%;height:100%}

  /* pannello controlli */
  .panel{width:min(96vw,1200px);margin:0 auto;background:var(--card);border-radius:12px;padding:10px;display:grid;gap:8px;grid-template-columns:repeat(6,1fr)}
  .group{background:rgba(255,255,255,.05);border-radius:10px;padding:8px;display:flex;flex-direction:column;gap:6px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{border:0;border-radius:10px;padding:9px 12px;background:#2a2a2a;color:#fff;font-weight:600;cursor:pointer}
  .btn-ghost{background:transparent;outline:1px solid rgba(255,255,255,.25)}
  input[type=range]{width:100%}

  /* hotspot numerati */
  .hotspot{
    position:absolute; width:24px;height:24px;border-radius:50%;
    background:#2b74ff;border:1px solid #fff; color:#fff;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 system-ui; box-shadow:0 2px 6px rgba(0,0,0,.45);
    transform:translate(-50%,-50%); cursor:pointer;
    z-index:10;
  }

  /* pannelli esterni */
  .popup{
    position:absolute; width: clamp(200px, 22vw, 280px); aspect-ratio: 1/1;
    background:rgba(18,18,18,.96); border:1px solid rgba(255,255,255,.25);
    border-radius:12px; padding:12px; display:none; overflow:auto; z-index:9;
  }
  .popup.show{display:block}
  .popup.right{transform:translate(80px,-50%)}
  .popup.left {transform:translate(-100%,-50%)}

  /* etichetta misura (CSS2D) */
  .label{
    padding:6px 8px;border-radius:8px;background:#111;color:#fff;
    border:1px solid rgba(255,255,255,.25); font:600 12px/1.2 system-ui;
    pointer-events:none;
  }
  /* badge modalitÃ  hotspot */
  .badge{
    position:absolute; top:8px; left:8px; z-index:20;
    padding:6px 8px; border-radius:8px;
    background:rgba(14,165,233,.12); color:#93c5fd; border:1px solid rgba(147,197,253,.35);
    font:600 12px/1.2 system-ui; display:none;
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Epigrafe Claudia Nova</h1>

  <div id="stage">
    <div id="badge" class="badge">HOTSPOT MODE</div>
    <!-- hotspot DIV e popup vengono creati da JS -->
  </div>

  <div class="panel">
    <div class="group">
      <label>Misurazione</label>
      <div class="row">
        <button id="measure" class="btn-ghost">Misura Aâ€“B</button>
        <button id="measureReset" class="btn-ghost">Reset</button>
      </div>
      <small id="mhelp" style="opacity:.75">Clicca A poi B sulla mesh.</small>
    </div>
    <div class="group">
      <label>Zoom (FOV)</label>
      <input id="fov" type="range" min="25" max="75" step="1" value="45">
    </div>
    <div class="group">
      <label>LuminositÃ </label>
      <input id="exposure" type="range" min="0.2" max="2.0" step="0.05" value="1.0">
    </div>
    <div class="group">
      <label>Camera</label>
      <div class="row">
        <button id="fit" class="btn-ghost">Inquadra</button>
        <button id="reset" class="btn-ghost">Reset</button>
      </div>
    </div>
    <div class="group">
      <label>Ambiente</label>
      <div class="row">
        <button class="btn-ghost env" data-hdr="on">HDR</button>
        <button class="btn-ghost env" data-hdr="off">None</button>
      </div>
    </div>
    <div class="group">
      <label>Hotspot</label>
      <div class="row">
        <button id="toggleH" class="btn-ghost">ModalitÃ  H</button>
      </div>
      <small>Premi anche la <b>H</b> da tastiera</small>
    </div>
  </div>
</div>

<!-- Three.js (moduli) -->
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

const stage = document.getElementById('stage');
const badge = document.getElementById('badge');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0e0e0e);

const camera = new THREE.PerspectiveCamera(45, stage.clientWidth/stage.clientHeight, 0.01, 100);
camera.position.set(0.7, 0.8, 1.6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(stage.clientWidth, stage.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
stage.appendChild(renderer.domElement);

// label renderer per etichette distanza
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(stage.clientWidth, stage.clientHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.left = '0';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
stage.appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 0.5, -1.05);

// luce morbida
const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(2,2,2);
scene.add(dir);

// HDR env (facoltativo)
let envTexture = null;
const rgbe = new RGBELoader();
rgbe.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/textures/equirectangular/venice_sunset_1k.hdr', (tex)=>{
  tex.mapping = THREE.EquirectangularReflectionMapping;
  envTexture = tex;
});

// GLB
let model = null;
const loader = new GLTFLoader();
await loader.loadAsync('https://edoarch94.github.io/DOTTORATO_UMAP2/modelli/Epigrafe.glb?v=9').then(g=>{
  model = g.scene;
  scene.add(model);
});

// --------- RAYCAST helper ----------
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
function setNDCFromEvent(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
}
function raycast(e){
  setNDCFromEvent(e);
  raycaster.setFromCamera(mouse, camera);
  // interseca tutti i figli del modello
  const hits = raycaster.intersectObject(model, true);
  return hits[0] || null;
}

// --------- MISURAZIONE ----------
const measureBtn = document.getElementById('measure');
const measureReset = document.getElementById('measureReset');
const mhelp = document.getElementById('mhelp');

const A = new THREE.Mesh(new THREE.SphereGeometry(0.01,16,16), new THREE.MeshBasicMaterial({color:0x22c55e}));
const B = A.clone();
A.visible = B.visible = false;
scene.add(A,B);

const lineMat = new THREE.LineBasicMaterial({color:0x22c55e});
const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
const lineAB = new THREE.Line(lineGeo, lineMat); lineAB.visible=false;
scene.add(lineAB);

const distLabelEl = document.createElement('div'); distLabelEl.className='label'; distLabelEl.textContent='0.000 m';
const distLabel = new CSS2DObject(distLabelEl);
distLabel.visible=false; scene.add(distLabel);

const measuring = {active:false, step:0, a:new THREE.Vector3(), b:new THREE.Vector3()};

function setMeasureActive(on){
  measuring.active = on; measuring.step = 0;
  A.visible = B.visible = lineAB.visible = distLabel.visible = false;
  mhelp.textContent = on ? 'Clicca A poi B sulla mesh.' : 'Clicca Aâ€“B per misurare.';
}

measureBtn.onclick = ()=> setMeasureActive(!measuring.active);
measureReset.onclick = ()=> setMeasureActive(false);

renderer.domElement.addEventListener('click', (e)=>{
  if(!measuring.active) return;
  const hit = raycast(e); if(!hit) return;

  if(measuring.step===0){
    measuring.a.copy(hit.point);
    A.position.copy(hit.point); A.visible = true;
    measuring.step = 1;
  } else {
    measuring.b.copy(hit.point);
    B.position.copy(hit.point); B.visible = true;

    lineAB.geometry.setFromPoints([measuring.a, measuring.b]); lineAB.visible=true;

    const mid = measuring.a.clone().add(measuring.b).multiplyScalar(0.5);
    distLabel.position.copy(mid); distLabel.visible=true;

    const d = measuring.a.distanceTo(measuring.b);
    distLabelEl.textContent = d.toFixed(3)+' m';
    measuring.step = 0; // pronto per nuova misura
  }
});

// --------- HOTSPOT & POPUP ----------
const stageRect = ()=> renderer.domElement.getBoundingClientRect();

// tuoi punti (in metri) + normali opzionali per zoom frontale
const HOTSPOTS = [
  { id:1, pos:new THREE.Vector3( 0.304,  0.179, -1.065), nor:new THREE.Vector3(0.006, 0.065, 0.998), title:'Lettera S', text:'Errato calcolo dello spazio â†’ lettera S incisa sopra la cornice.' },
  { id:2, pos:new THREE.Vector3( 0.297, -0.112, -1.060), nor:new THREE.Vector3(0.544, 0.017, 0.839), title:'Lettera M', text:'Ravvicinamento delle lettere e sbordatura della M sulla cornice.' },
  { id:3, pos:new THREE.Vector3(-0.144, -0.275, -1.009), nor:new THREE.Vector3(0.075, 0.053, 0.996), title:'ATTERNUM', text:'Variante locale (rif. CIL IX 5979), possibile influsso osco-umbro.' },
  { id:4, pos:new THREE.Vector3( 0.347,  0.325, -1.072), nor:new THREE.Vector3(0.162,-0.003, 0.987), title:'Supporto lapideo', text:'Pietra calcarea con tonalitÃ  rossastra nello specchio epigrafico.' }
];

// crea hotspot DIV + popup
const hUI = HOTSPOTS.map(h=>{
  const btn = document.createElement('div');
  btn.className = 'hotspot'; btn.textContent = h.id;
  stage.appendChild(btn);

  const pop = document.createElement('div');
  pop.className = 'popup';
  pop.innerHTML = `<strong>${h.title}</strong><br>${h.text}`;
  stage.appendChild(pop);

  btn.addEventListener('click',(e)=>{
    e.stopPropagation();
    // zoom frontale adattivo
    focusOn(h.pos, h.nor);
    // pannello: lato in base alla x proiettata
    const r = stageRect();
    const s = h.pos.clone().project(camera);
    const px = (s.x*0.5+0.5)*r.width;
    pop.style.top = ((-s.y*0.5+0.5)*r.height) + 'px';
    pop.style.left = px + 'px';
    pop.classList.remove('left','right');
    pop.classList.add( px < r.width/2 ? 'right' : 'left' );

    document.querySelectorAll('.popup.show').forEach(p=>{ if(p!==pop) p.classList.remove('show'); });
    pop.classList.toggle('show');
  });

  return {h, btn, pop};
});

// aggiorna posizione schermo degli hotspot
function updateHotspotScreenPositions(){
  const r = stageRect();
  hUI.forEach(({h,btn,pop})=>{
    const s = h.pos.clone().project(camera);
    btn.style.left = ((s.x*0.5+0.5)*r.width) + 'px';
    btn.style.top  = ((-s.y*0.5+0.5)*r.height) + 'px';
    // se il popup Ã¨ aperto, riallinea la y
    if(pop.classList.contains('show')){
      pop.style.top = btn.style.top;
    }
  });
}

// zoom frontale: porta target al punto e sposta camera di una distanza in direzione della normale o della direzione camera->punto
function focusOn(point, normal){
  controls.target.copy(point);
  const r = camera.position.distanceTo(controls.target);
  const dist = THREE.MathUtils.clamp(r*0.4, 0.2, 0.7);

  let dir = normal ? normal.clone().normalize() : camera.position.clone().sub(point).normalize();
  const newPos = point.clone().add(dir.multiplyScalar(dist));
  camera.position.lerp(newPos, 1.0);
  camera.lookAt(point);
}

// --------- AMBIENTE / UI ---------
document.getElementById('fov').oninput = e => { camera.fov = +e.target.value; camera.updateProjectionMatrix(); };
document.getElementById('exposure').oninput = e => { renderer.toneMappingExposure = +e.target.value; };
document.getElementById('fit').onclick = ()=>{
  controls.target.set(0,0.5,-1.05); camera.position.set(0.7,0.8,1.6);
};
document.getElementById('reset').onclick = ()=>{
  controls.reset(); controls.target.set(0,0.5,-1.05);
  camera.fov = 45; camera.updateProjectionMatrix();
};
document.querySelectorAll('.env').forEach(b=>{
  b.onclick = ()=>{
    if(b.dataset.hdr==='on' && envTexture){ scene.environment = envTexture; }
    else { scene.environment = null; }
  };
});

// --------- MODALITÃ€ HOTSPOT (H) per leggere coordinate ----------
let hotspotMode = false;
function toggleH(){
  hotspotMode = !hotspotMode;
  badge.style.display = hotspotMode ? 'block' : 'none';
  console.log(hotspotMode ? 'ðŸŸ¦ Hotspot mode ON â€” clicca la pietra per ottenere il blocco HTML.' : 'â¬› Hotspot mode OFF');
}
document.getElementById('toggleH').onclick = toggleH;
window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='h') toggleH(); });

renderer.domElement.addEventListener('click', (e)=>{
  if(!hotspotMode) return;
  const hit = raycast(e); if(!hit) return;
  const p = hit.point, n = hit.face?.normal?.clone().transformDirection(hit.object.matrixWorld) || new THREE.Vector3(0,0,1);
  const pos = `${p.x.toFixed(3)}m ${p.y.toFixed(3)}m ${p.z.toFixed(3)}m`;
  const nor = `${n.x.toFixed(3)}m ${n.y.toFixed(3)}m ${n.z.toFixed(3)}m`;
  console.clear();
  console.log(`data-position="${pos}"\ndata-normal="${nor}"`);
});

// --------- RENDER LOOP ----------
function onResize(){
  const w = stage.clientWidth, h = stage.clientHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h);
  labelRenderer.setSize(w,h);
  updateHotspotScreenPositions();
}
window.addEventListener('resize', onResize);

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  updateHotspotScreenPositions();
}
onResize();
animate();

</script>
</body>
</html>
